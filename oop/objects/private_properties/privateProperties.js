// Инкапсуляция является одним из ключевых понятий объектно-ориентированного программирования и представляет сокрытие
// состояния объекта от прямого доступа извне. По умолчанию все свойства объектов являются публичными, общедоступными,
// и мы к ним можем обратиться из любого места программы.
function User(pName, pAge) {
  this.name = pName;
  this.age = pAge;
  this.displayInfo = function(){
    document.write("Имя: " + this.name + "; возраст: " + this.age);
  };
};
let tom = new User("Том", 26);
tom.name=34;
console.log(tom.name);

// Но мы можем их скрыть от доступа извне, сделав свойства локальными переменными:
function User2 (name, age) {
  this.name = name;
  let _age = age;
  this.displayInfo = function(){
    document.write("Имя: " + this.name + "; возраст: " + _age + "<br>");
  };
  this.getAge = function() {
    return _age;
  }
  this.setAge = function(age) {
    if(typeof age === "number" && age >0 && age<110){
      _age = age;
    } else {
      console.log("Недопустимое значение");
    }
  }
}
tom = new User2("Том", 26);
console.log(tom._age); // undefined - _age - локальная переменная
console.log(tom.getAge()); // 26
tom.setAge(32);
console.log(tom.getAge()); // 32
tom.setAge("54"); // Недопустимое значение
// В конструкторе User объявляется локальная переменная _age вместо свойства age. Как правило, названия локальных
// переменных в конструкторах начинаются со знака подчеркивания.
// Для того, чтобы работать с возрастом пользователя извне, определяются два метода. Метод getAge() предназначен для
// получения значения переменной _age. Этот метод еще называется геттер (getter). Второй метод - setAge, который еще
// называется сеттер (setter), предназначен для установки значения переменной _age.
// Плюсом такого подхода является то, что мы имеем больший контроль над доступом к значению _age. Например, мы можем
// проверить какие-то сопутствующие условия, как в данном случае проверяются тип значение (он должен представлять
// число), само значение (возраст не может быть меньше 0).