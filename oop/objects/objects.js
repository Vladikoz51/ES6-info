// В прошлых темах мы работали с примитивными данными - числами, строками, но данные не всегда представляют примитивные
// типы. Например, если в нашей программе нам надо описать сущность человека, у которого есть имя, возраст, пол и так
// далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько
// строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная
// структура, у которого будут отдельные свойства - возраст, рост, имя, фамилия и т.д.
//
// Для работы с подобными структурами в JavaScript используются объекты. Каждый объект может хранить свойства, которые
// описывают его состояние, и методы, которые описывают его поведение.


// Создание нового объекта.
// Есть несколько способов создания нового объекта.
// Первый способ заключается в использовании конструктора Object:
let user = new Object();
// Выражение new Object() представляет вызов конструктора - функции, создающей новый объект. Для вызова конструктора
// применяется оператор new. Вызов конструктора фактически напоминает вызов обычной функции.
// Второй способ создания объекта представляет использование фигурных скобок:
let user2 = {};


// Свойства объекта:
// После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта
// через точку указать имя свойства и присвоить ему значение:
user2.name = 'Tom';
user2.age = 26;
console.log(user2.name);
console.log(user2.age);
// Также можно определить свойства при определении объекта:
const user3 = {name: 'Vladimir', age: 34};
// Кроме того, доступен сокращенный способ определения свойств:
let name = 'Tom';
let age = 26;
const user4 = {name, age};
// В данном случае названия переменных также являются и названиями свойств объекта. И таким образом можно создавать
// более сложные конструкции:
const teacher = {user4, course: 'JavaScript'};
console.log(teacher.user4);
console.log(teacher.course);


// Методы объекта:
// Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции.
// Например, определим метод, который бы выводил имя и возраст человека:
user3.display = function () {
  console.log(this.name);
  console.log(this.age);
};
// Как и в случае с функциями методы сначала определяются, а потом уже вызываются.
// Также методы могут определяться непосредственно при определении объекта:
let user5 = {
  name: "Tom",
  age: 26,
  display: function() {
    console.log(this.name);
    console.log(this.age);
  }
};
// Как и в случае со свойствами, методу присваивается ссылка на функцию с помощью знака двоеточия.
// Чтобы обратиться к свойствам или методам объекта внутри этого объекта, используется ключевое слово this. Оно означает
// ссылку на текущий объект.
// Также можно использовать сокращенный способ определения методов, когда двоеточие и слово function опускаются:
let user6 = {

  name: "Tom",
  age: 26,
  display() {
    console.log(this.name, this.age);
  },
  move(place) {
    console.log(this.name, "goes to", place);
  }
};
user6.display(); // Tom 26
user6.move("the shop");  // Tom goes to the shop


// Синтаксис массивов:
// Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:
let user7 = {};
user7["name"] = "Tom";
user7["age"] = 26;
user7["display"] = function() {
  console.log(user7.name);
  console.log(user7.age);
};
// вызов метода
user7["display"]();
// Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается
// значение. Например, user["age"] = 26.
// При обращении к этим свойствам и методам можно использовать либо нотацию точки (user.name),
// либо обращаться так: user["name"]
// Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:
let user8 = {
  ["name"]: "Tom",
  ["age"]: 26,
  ["display"]: function() {
    console.log(user8.name);
    console.log(user8.age);
  }
};
user8["display"]();


// Строки в качестве свойств и методов:
// Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли
// предыдущее определение объекта переписать так:
user8 = {
  "name": "Tom",
  "age": 26,
  "display": function() {
    console.log(user8.name);
    console.log(user8.age);
  }
};
user8.display();
// С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение
// названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:
let user9 = {
  name: "Tom",
  age: 26,
  "full name": "Tom Johns",
  "display info": function() {
    console.log(user.name);
    console.log(user.age);
  }
};
// Только в этом случае для обращении к подобным свойствам и методам мы должны использовать синтаксис массивов.
console.log(user9["full name"]);
user9["display info"]();


// Динамическое определение имен свойств и методов:
// Синтаксис массивов открывает нам другую возможность - определение имени свойства вне объекта:
const prop1  = "name";
const prop2  = "age";
let tom = {
  [prop1]: "Tom",
  [prop2]: 37
};
console.log(tom);           // {name: "Tom", age: 37}
console.log(tom.name);      // Tom
console.log(tom["age"]);    // 37
// Благодаря этому, например, можно динамически создавать объекты с произвольными названиями свойств:
function createObject(propName, propValue) {
  return {
    [propName]: propName,
    print() {
      console.log(`${propName}: ${propValue}`);
    }
  };
}
let person = createObject("name", "Tom");
person.print();     // name: Tom
let book = createObject("title", "JavaScript Reference");
book.print();   // title: JavaScript Reference


// Удаление свойств
// Выше мы посмотрели, как можно динамически добавлять новые свойства к объекту. Однако также мы можем удалять свойства
// и методы с помощью оператора delete. И как и в случае с добавлением мы можем удалять свойства двумя способами.
// Первый способ - использование нотации точки:
// delete объект.свойство
// Либо использовать синтаксис массивов:
// delete объект["свойство"]
// Например, удалим свойство:
let user10 = {};
user10.name = "Tom";
user10.age = 26;
user10.display = function() {
  console.log(user.name);
  console.log(user.age);
};
console.log(user10.name); // Tom
delete user10.name; // удаляем свойство
// альтернативный вариант
// delete user10["name"];
console.log(user10.name); // undefined
// После удаления свойство будет не определено, поэтому при попытке обращения к нему, программа вернет значение
// undefined.


// Константные объекты
// Возможно, нам потребуется, чтобы объект нельзя было изменить, то есть сделать константным. Однако просто определить
// его как обычную константу с помощью оператора const недостаточно. Например:
const person2 = {name: "Tom", age: 37};
person2.name= "Bob";
console.log(person2.name);   // Bob
// Здесь мы видим, что свойство объекта изменило свое значение, хотя объект определен как константа.
// Оператор const лишь влияет на то, что мы не можем присвоить константе новое значение, например, как в следующем
// случае:
// person2 = {name: 'Sam', age: 56}; // Uncaught TypeError: Assignment to constant variable.
// Тем не менее значения свойств объекта мы можем изменять.
// Чтобы сделать объект действительно константным, необходимо применить специальный метод Object.freeze(). В этот метод
// в качестве параметра передается объект, который надо сделать константным:
const person3 = {name: "Tom", age: 37};
Object.freeze(person3);
person3.name= "Bob";
console.log(person3.name);   // Tom - значение свойства не изменилось


// Создание объекта из переменных и констант:
// При создании объекта его свойствам могут передаваться значения переменных, констант или динамически вычисляемые
// результаты функций:
function getSalary(status) {
  if (status==="senior") {return 1500;}
  else {return 500;}
}
const name4 = "Tom";
const age4 = 37;
const person4 = { name: name4, age: age4, salary: getSalary()};

console.log(person4);    // {name: "Tom", age: 37, salary: 500}
// Но если названия констант/переменных совпадает с названиями свойств, то можно сократить передачу значений:
const name5 = "Tom";
const age5 = 37;
const salary5 = 500;
const person5 = { name5, age5, salary5};
console.log(person5);    // {name5: "Tom", age5: 37, salary5: 500}
// В данном случае объект person автоматически получит свойства, названия которых будут соответствовать названиям
// констант, а в качестве значений иметь значения этих констант.
// То же самое относится к передаче функций методам объекта:
function display6() {
  console.log(this.name, this.age);
}
const move = function(place) { console.log(this.name, "goes to", place)};
const name6 = "Tom";
const age6 = 37;
const salary6 = 500;
const person6 = { name6, age6, salary6, display6, move};
person6.display6();       // Tom 37
person6.move("cinema");  // Tom goes to cinema
// В данном случае объект person имеет два метода, которые соответствуют переданным в объект функциям - display() и
// move(). Стоит отметить, что при такой передаче функций методам объекта, мы по прежнему можем использовать в этих
// функциях ключевое слово this для обращения к функциональности объекта. Однако стоит быть осторожным при передаче
// стрелочных функций, поскольку для глобальных стрелочных функций this будет представлять объект окна браузера:
const move2 = (place)=>{ console.log(this.name, "goes to", place); console.log(this);};
const name7 = "Tom";

const person7 = { name7, move2};
person7.move2("cinema");  //  goes to cinema


// Функция Object.fromEntries()
// С помощью функции Object.fromEntries() можно создать объект из набора пар ключ-значение, где ключ потом будет
// представляет название свойства. Например, создадим объект из массивов:
const personData = [ ["name", "Tom"], ["age", 37]];
const person8 = Object.fromEntries(personData);
console.log(person8);        // {name: "Tom", age: 37}
console.log(person8.name);    // Tom
// Здесь объект создается из массива personData, который содержит два подмассива. Каждый подмассив содержит два элемента
// и фактически представляет пару ключ-значение. Первый элемент представляет ключ, а второй - значение.


