// Функции представляют собой набор инструкций, которые выполняют определенное действие или вычисляют определенное
// значение.
// Синтаксис определения функции:
// function имя_функции([параметр [, ...]]){
//   // Инструкции
// }
// Определение функции начинается с ключевого слова function, после которого следует имя функции. Наименование функции
// подчиняется тем же правилам, что и наименование переменной: оно может содержать только цифры, буквы, символы
// подчеркивания и доллара ($) и должно начинаться с буквы, символа подчеркивания или доллара.
// Определим простейшую функцию:
function hello() {
  console.log("Hello Metanit.com");
}

// Чтобы функция выполнила свою работу, нам надо ее вызвать. Общий синтаксис вызова функции:
// имя_функции(аргументы).
// При вызове после имени вызываемой функции в скобках указывается список аргументов. Если функция не имеет параметров,
// то указываются пустые скобки.
hello();

// Переменные и константы в качестве функций:
// Подобно тому, как константам и переменным присваиваются простейшие значения (числа, строки и т.д.), также им можно
// присваивать функции. Затем через такую переменную или константу можно вызвать присвоенную ей функцию:
let message = hello;
message();

// Также мы можем динамически менять функции, которые хранятся в переменной:
function goodMorning(){
  console.log("Доброе утро");
}
function goodEvening(){
  console.log("Добрый вечер");
}
message = goodMorning;      // присваиваем переменной message функцию goodMorning
message();      // Доброе утро
message = goodEvening;          // меняем функцию в переменной message
message();      // Добрый вечер


// Анонимные функции
// Необязательно давать функциям определенное имя. Можно использовать анонимные функции:
message = function() {
  console.log("Hello JavaScript");
}
message();


//-----------------------------------------------Параметры функции------------------------------------------------------
// Функция в JavaScript может принимать параметры. Параметры представляют способ передачи в функцию данных. Параметры
// указываются в скобках после названия функции.
// Например, определим простейшую функцию, которая принимает один параметр:
function print(message) {
  console.log(message);
}
// Функция print() принимает один параметр - message. Поэтому при вызове функции мы можем передать для него значение,
// например, некоторую строку:
print("Hello JavaScript");
print("Hello METANIT.COM");
print("Function in JavaScript");
// Передаваемые параметрам значения называют аргументами, если параметру не передается значение, тогда он будет иметь
// значение undefined.
// Если функция принимает несколько параметров, то они перечисляются через запятую:
function sum1(a, b){
  const result = a + b;
  console.log(result);
}
// При вызове функции с несколькими параметрами значения передаются параметрам по позиции. То есть первое значение
// передается первому параметру, второе значение - второму и так далее. Например, в вызове:
sum1(2, 6);          // 8
sum1(4, 5);          // 9
sum1(109, 11);       // 120

// Необязательные параметры и значения по умолчанию:
// Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если
// для параметров не передается значение, то по умолчанию они имеют значение "undefined". Однако иногда бывает
// необходимо, чтобы параметры обязательно имели какие-то значения, например, значения по умолчанию. До стандарта ES6
// необходимо было проверять значения параметров на undefined:
function sum2(x, y) {
  if(y === undefined) y = 5;
  if(x === undefined) x = 8;
  const z = x + y;
  console.log(z);
}
// Теперь мы можем напрямую определять для параметров значения по умолчанию:
function sum3(x = 8, y = 5) {
  const z = x + y;
  console.log(z);
}
sum3();      // 13
sum3(6);     // 11
sum3(6, 4)   // 10
// При этом значение параметра по умолчанию может быть производным, представлять выражение:
function sum4(x = 8, y = 10 + x) {
  const z = x + y;
  console.log(z);
}
sum4();      // 26
sum4(6);     // 22
sum4(6, 4)   // 10

// Массив arguments
// При необходимости мы можем получить все переданные параметры через глобально доступный массив arguments:
function sum5() {
  let result = 0;
  for (const n of arguments) {
    result += n;
  }
  console.log(result);
}
sum5(6);             // 6
sum5(6, 4)           // 10
sum5(6, 4, 5)        // 15
// При этом даже не важно, что при определении функции мы не указали никаких параметров, мы все равно можем их передать
// и получить их значения через массив arguments.

// Неопределенное количество параметров
// С помощью оператора ... (многоточие) мы можем указать, что с помощью параметра можно передать переменное
// количество значений:
function display(season, ...temps) {
  console.log(season);
  for(const index in temps){
    console.log(temps[index]);
  }
}
display("Весна", -2, -3, 4, 2, 5);
display("Лето", 20, 23, 31);

// Функции в качестве параметров
// Функции могут выступать в качестве параметров других функций:
function sum6(x, y){
  return x + y;
}

function subtract(x, y){
  return x - y;
}

function operation(x, y, func){

  const result = func(x, y);
  console.log(result);
}

console.log("Sum");
operation(10, 6, sum6);  // 16

console.log("Subtract");
operation(10, 6, subtract); // 4
// Функция operation принимает три параметра: x, y и func. func - представляет функцию, причем на момент определения
// operation не важно, что это будет за функция. Единственное, что известно, что функция func может принимать два
// параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому мы можем определить
// различные функции (например, функции sum и subtract в данном случае) и передавать их в вызов функции operation.


//----------------------------------------------Результат функции-------------------------------------------------------
// Функция может возвращать результат. Для этого используется оператор return, после которого указывается возвращаемое
// значение:
function sum (a, b) {
  const result = a + b;
  return result;
}
// После получения результата функции мы можем присвоить его какой-либо другой переменной или константе:
function sum (a, b) {
  return a + b;
}
let num1 = sum(2, 4);
console.log(num1);  // 6

const num2 = sum(6, 34);
console.log(num2);  // 40

// Возвращение функции из функции
// Одна функция может возвращать другую функцию:
function menu(n) {
  if (n == 1) {
    return function(x, y) { return x + y;}
  }
  else if(n == 2) {
    return function(x, y) { return x - y;}
  }
  else if(n == 3) {
    return function(x, y) { return x * y;}
  }
  return function() { return 0;}
}

const action = menu(1);         // выбираем первый пункт - сложение
const result = action(2, 5);    // выполняем функцию и получаем результат в константу result
console.log(result);            // 7


//--------------------------------------Передача параметров по значению и по ссылке-------------------------------------
// Строки, числа, логические значения передаются в функцию по значению. Иными словами при передаче значения в функцию,
// эта функция получает копию данного значения. Рассмотрим, что это значит в практическом плане:
function change(x) {
  x = 2 * x;
  console.log("x in change:", x);
}

let n = 10;
console.log("n before change:", n); // n before change: 10
change(n);                          // x in change: 20
console.log("n after change:", n);  // n after change: 10
// Функция change получает некоторое число и увеличивает его в два раза. При вызове функции change ей передается число
// n. Однако после вызова функции мы видим, что число n не изменилось, хотя в самой функции произошло увеличение
// значения параметра. Потому что при вызове функция change получает копию значения переменной n. И любые изменения с
// этой копией никак не затрагивают саму переменную n.


// Передача по ссылке
// Объекты и массивы передаются по ссылке. То есть функция получает сам объект или массив, а не их копию.
function change2(user) {
  user.name = "Tom";
}

let bob ={
  name: "Bob"
};
console.log("before change:", bob.name);    // Bob
change2(bob);
console.log("after change:", bob.name);     // Tom
// В данном случае функция change получает объект и меняет его свойство name. В итоге мы увидим, что после вызова
// функции изменился оригинальный объект bob, который передавался в функцию.
// Однако если мы попробуем переустановить объект или массив полностью, оригинальное значение не изменится.
function change3(user) {
  // полная переустановка объекта
  user = {
    name:"Tom"
  };
}

let bob2 ={
  name: "Bob"
};
console.log("before change:", bob2.name);    // Bob
change(bob2);
console.log("after change:", bob2.name);     // Bob

// То же самое касается массивов:
function change4(array){
  array[0] = 8;
}
function changeFull(array){
  array = [9, 8, 7];
}

let numbers = [1, 2, 3];

console.log("before change:", numbers);     // [1, 2, 3]
change4(numbers);
console.log("after change:", numbers);      // [8, 2, 3]
changeFull(numbers);
console.log("after changeFull:", numbers);  // [8, 2, 3]