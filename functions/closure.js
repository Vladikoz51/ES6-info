// Замыкание (closure) представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает
// свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.
// Замыкание технически включает три компонента:
// 1. Внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные -
// лексическое окружение
// 2. Переменные (лексическое окружение), которые определены во внешней функции.
// 3. Вложенная функция, которая использует эти переменные.

function outer() {       // внешняя функция
  let n;              // некоторая переменная
  return function inner() {     // вложенная функция
    // действия с переменной n
  }
}

// Рассмотрим замыкания на простейшем примере:
function outer2() {
  let x = 5;
  function inner() {
    x++;
    console.log(x);
  }
  return inner;
}
let fn = outer2();   // fn = inner, так как функция outer2 возвращает функцию inner
// вызываем внутреннюю функцию inner
fn();   // 6
fn();   // 7
fn();   // 8
// Несмотря на то, что переменная x определена вне функции inner, эта функция запомнила свое окружение и может его
// использовать, несмотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть
// замыканий.


// Рассмотрим еще один пример:
function multiply(n) {
  let x = n;
  return function(m) { return x * m;};
}
// fn1 — это замыкание, которое содержит и внутреннюю функцию function(m){ return x * m;}, и переменную x, которая
// существовала во время создания замыкания.
let fn1 = multiply(5);
let result1 = fn1(6); // 30
console.log(result1); // 30

// При создании двух замыканий: fn1 и fn2, для каждого из этих замыканий создается свое окружение.
let fn2= multiply(4);
let result2 = fn2(6); // 24
console.log(result2); // 24
