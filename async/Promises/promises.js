// При стандартном выполнении JavaScript инструкции выполняются последовательно, одна за другой. То есть сначала
// выполняется первая инструкция, потом вторая и так далее. Однако что, если одна из этих операций выполняется
// продолжительное время. Например, она выполняет какую-то высоконагруженную работу, как обращение по сети или обращение
// к базе данных, что может занять неопределенное и иногда продолжительное время. В итоге при последовательном
// выполнении все последующие операции будут ожидать выполнения этой операции. Чтобы избежать подобной ситуации
// JavaScript предоставляет ряд инструментов, которые позволяют избежать подобного сценария, чтобы последующие операции
// могли выполняться, пока выполняется продолжительная операция. Одним из таким инструментов являются промисы (promise).

// Промис (promise) - это объект, представляющий результат успешного или неудачного завершения асинхронной операции.
// Асинхронная операция, упрощенно говоря, это некоторое действие, выполняется независимо от окружающего ее кода, в
// котором она вызывается, не блокирует выполнение вызываемого кода.
// Промис может находиться в одном из следующих состояний:
// pending (состояние ожидания): начальное состояние, промис создан, но выполнение еще не завершено
// fulfilled (успешно завершено): действие, которое представляет промис, успешно завершено
// rejected (завершено с ошибкой): при выполнении действия, которое представляет промис, произошла ошибка

// Для создания промиса применяется конструктор типа Promise:
// new Promise(executor)
// В качестве параметра конструктор принимает функцию, которая выполняется при создании промиса. Обычно эта функция
// представляет асинхронные операции, которые занимают продолжительное время. Например, определим простейший промис:
let myPromise = new Promise(function(){
    console.log("Выполнение асинхронной операции");
});
// Здесь функция просто выводит на консоль сообщение. Соответственно при выполнении этого кода мы увидим на консоли
// сообщение "Выполнение асинхронной операции".
// При создании промиса, когда его функция еще не начала выполняться, промис переходит в состояние "pending", то есть
// ожидает выполнения.
// Как правило, функция, которая передается в конструктор Promise, принимает два параметра:
myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
});
// Оба этих параметра - resolve и reject также представляют функции. И каждая из этих функций принимает параметр любого
// типа.
// Первый параметр - функция resolve вызывается в случае успешного выполнения. Мы можем в нее передать значение, которое
// мы можем получить в результате успешного выполнения.
// Второй параметр - функция reject вызывается, если выполнение операции завершилось с ошибкой. Мы можем в нее передать
// значение, которое представит некоторую информацию об ошибке.


//------------------------------------------Успешное выполнение промиса-------------------------------------------------
// Итак, первый параметр функции в конструкторе Promise - функция resolve выполняется при успешном выполненим. В эту
// функцию обычно передается значение, которое представляет результат операции при успешном выполнении. Это значение
// может представлять любой объект. Например, передадим в эту функцию строку:
myPromise = new Promise(function(resolve) {
    console.log("Выполнение асинхронной операции");
    resolve("Привет мир!");
});
// Функция resolve() вызывается в конце выполняемой операции после всех действий. При вызове этой функции промис
// переходит в состояние fulfilled (успешно выполнено).
// При этом стоит отметить, что теоретически мы можем возвратить из функции результат, но практического смысла в этом
// не будет:
myPromise = new Promise(function(resolve, reject) {
    console.log("Выполнение асинхронной операции");
    return "Привет мир!";
});
// Данное возвращаемое значение мы не сможем передать во вне. И если действительно надо возвратить какой-то результат,
// то он передается в функцию resolve().


// Передача информации об ошибке
// Второй параметр функции в конструкторе Promise - функция reject вызывается при возникновении ошибки. В эту функцию
// обычно передается некоторая информация об ошибке, которое может представлять любой объект. Например:
myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
    reject("Переданы некорректные данные");
});
// При вызове функции reject() промис переходит в состояние rejected (завершилось с ошибкой).


// Объединение resolve и reject
// Естественно мы можем определить логику, при которой в зависимости от условий будут выполняться обе функции:
const x = 4;
const y = 0;
myPromise = new Promise(function(resolve, reject){
    if (y === 0) {
        reject("Переданы некорректные данные");
    }
    else{
        const z = x / y;
        resolve(z);
    }
});


//----Promises----

//"I Promise a Result!"

//"Producing code" is code that can take some time

//"Consuming code" is code that must wait for the result

//A Promise is a JavaScript object that links producing code and consuming code

let str = "This is a string!!!";
console.log(str);

const p = new Promise((resolve, reject) => {
    setTimeout(() => {
        str += " This is another string.";
        console.log(str);
        resolve(str);
    }, 10000);
});
p.then((data) => {
    return data += " And another string.";
}).then((data) => {
    setTimeout(() => {data += " The end;"; console.log(data)}, 5000)
});
