// Для получения результата операции промиса применяется функция then() объекта Promise:
// then(onFulfilled, onRejected)
// Первый параметр функции - onFulfilled представляет функцию, которая выполняется при успешном завершении промиса и в
// качестве параметра получает переданные в resolve() данные.
// Второй параметр функции - onRejected представляет функцию, которая выполняется при возникновении ошибки и в качестве
// параметра получает переданные в reject() данные.

// Функция then() возвращает также объект Promise.
// Так, получим переданные данные:
let myPromise = new Promise(function(resolve) {
  console.log("Выполнение асинхронной операции");
  resolve("Привет мир!");
});
myPromise.then(function(value) {
  console.log(`Из промиса получены данные: ${value}`);
});

// При этом нам необязательно вообще передавать в resolve() какое-либо значение. Возможно, асинхронная операция просто
// выполняется и не передает вовне никакого результата.
let x = 4;
let y = 8;
myPromise = new Promise(function() {
  console.log("Выполнение асинхронной операции");
  const z = x + y;
  console.log(`Результат операции: ${z}`)
});
myPromise.then();


//----------------------------------------------Метод Promise.resolve---------------------------------------------------
// Иногда требуется просто вернуть из промиса некоторое значение. Для этого можно использовать метод Promise.resolve().
// В этот метод передается возвращаемое из промиса значение. Метод Promise.resolve() возвращает объект Promise:
myPromise = Promise.resolve("Привет мир!");
myPromise.then(value => console.log(value));     // Привет мир!


//---------------------------------------Определение промиса через функцию----------------------------------------------
// Нередко промис определяется через функцию, которая возвращает объект Promise. Например:
function sum(x, y) {
  return new Promise(function(resolve) {
    const result = x + y;
    resolve(result);
  })
}
sum(3, 5).then(function(value){ console.log("Результат операции:", value);});
sum(25, 4).then(function(value){ console.log("Сумма чисел:", value);});
// Поскольку метод then() также возвращает объект Promise, то мы можем сделать следующим образом:
function sum2(x, y) {
  return new Promise(function(resolve){
    const result = x + y;
    resolve(result);
  }).then(function(value){ console.log("Результат операции:", value);});
}
sum2(3, 5);
sum2(25, 4);

// Гибкая настройка функции
// А что, если мы хотим, чтобы у программиста был выбор: если он хочет, то может определить свой обработчик, а если нет,
// то применяется некоторый обработчик по умолчанию. В этом случае мы можем определить функцию обработчика в качестве
// параметра функции, а если он не передан, то устанавливать обработчик по умолчанию:
function sum3(x, y, func) {
  // если обработчик не установлен, то устанавливаем обработчик по умолчанию
  if (func === undefined) {
    func = function(value) {console.log("Результат операции:", value);}
  }
  return new Promise(function(resolve){
    const result = x + y;
    resolve(result);
  }).then(func);
}
sum3(3, 5);
sum3(25, 4, function(value){ console.log("Сумма:", value);});