// Итераторы применяются для организации последовательного доступа к элементам наборов данных - массивам, объектам Set,
// Map, строкам и т.д..Так, благодаря итераторам мы можем перебрать набор данных с помощью цикла for-of:
let people = ["Tom", "Bob", "Sam"];
for(const person of people) {
  console.log(person);
}
// В цикле for-of справа от оператора of указывается набор данных или перебираемый объект, из которого в цикле мы можем
// получить отдельные элементы. Но эта возможность перебора некоторого объекта, как, например, массива в примере выше,
// реализуются благодаря тому, что эти объекты применяют итераторы. Рассмотрим подробнее, что представляют итераторы и
// как можно создать свой итератор.

// Итераторы предоставляют метод next(), который возвращает объект с двумя свойствами: value и done
// Свойство value хранит собственно значение текущего перебираемого элемента. А свойство done указывает, есть ли еще в
// коллекции объекты, доступные для перебора. Если в наборе еще есть элементы, то свойство done равно false Если же
// доступных элементов для перебора больше нет, то это свойство равно true, а метод next() возвращает объект
// {done: true}.

// Некоторые типы в JavaScript имеют методы, которые возвращают итераторы. Например, метод entries() типа Array (то есть
// массивов):
people = ["Tom", "Bob", "Sam"];
const items = people.entries();
console.log(items.next());
// Здесь метод next() возвратит следующий объект на консоль:
// {value: Array(2), done: false}
// 	done:	false
// 	value:	Array(2)
// 		0:	0
// 		1:	"Tom"
// 		length:	2
// 	__proto__:	Array(0)
// __proto__:	Object

// Здесь мы видим, что свойство done имеет значение false, так как мы перебрали только один элемент в множестве, и там
// еще есть два элемента.
// Свойство value представляет массив из двух значений. Первое значение представляет ключ или индекс элемента массива, а
// второй элемент - значение по этому индексу.

// Соответственно мы можем организовать и перебор всей коллекции:
let item;
while (!(item = items.next()).done) {
  console.log(item.value);
}
// Но в этом нет смысла, поскольку все коллекции, которые возвращают итераторы, поддерживают перебор с помощью цикла
// for...of, который как раз и использует итератор для получения элементов.
// Разные объекты могут иметь свою собственную реализацию итератора. И при необходимости мы можем определить объект со
// своим итератором. Применение итераторов предоставляет нам способ создать объект, который будет вести себя как
// коллекция элементов.


